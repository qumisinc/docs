---
title: "Git Branching Strategies"
description: "A comprehensive guide to managing feature branches for the engineering team"
icon: "git-branch"
noindex: true
---

## Overview

This guide addresses a common challenge in our Git workflow: what to do when your local branches fall behind the remote `release` branch while you're working on a feature.

### Our Current Branch Structure

```
main
└─ release
   └─ <feature branches>
```

Feature branches follow the Linear naming convention:
- **Format**: `engineer-name/ticket-id-description`
- **Example**: `erik/eng-983-establish-minimal-prod`

### Standard Workflow

1. Branch off from `release`
2. Make commits to your feature branch
3. Create a Pull Request (PR) with `release` as the base branch
4. Get approval from at least one other engineer
5. Merge the PR into `release`

## The Problem: Out-of-Sync Branches

When another engineer merges their feature into `release` while you're still working, your local branches become out of sync with the remote.

<Warning>
Creating a PR without updating your branches first leads to several problems.
</Warning>

### What Happens When You Don't Update

- Your PR shows other people's commits mixed with yours
- Code reviewers see changes you didn't make, causing confusion
- The true scope of your feature gets buried
- Merge conflicts are harder to resolve
- Attribution and `git blame` history become misleading

### Example Scenario

| Timeline | What Happens |
|----------|-------------|
| Day 1 | Engineer A and B both create feature branches from `release` |
| Day 2 | Engineer A completes their feature and merges into `release` |
| Day 3 | Engineer B creates a PR without updating—it shows A's commits! |

This makes the code review confusing and can lead to rejecting valid PRs or approving problematic ones.

## Solution 1: Rebase Strategy (Recommended)

Rebasing creates a **clean, linear history** by moving your commits to the tip of the updated `release` branch. **This is our recommended approach**. It makes it appear as if you just started your work from the current state of `release`.

<Steps>

### Update your local release branch

```bash
git checkout release
git pull origin release
```

### Switch back to your feature branch

```bash
git checkout erik/eng-984-your-feature
```

### Rebase your feature branch onto the updated release

```bash
git rebase release
```

### Push with force (safely)

```bash
git push --force-with-lease
```

</Steps>

### Handling Rebase Conflicts

If conflicts occur, Git will pause:

1. Edit the conflicted files to resolve the issues
2. Add the resolved files: `git add <file-names>`
3. Continue the rebase: `git rebase --continue`
4. Repeat until all commits are processed

### Advantages & Disadvantages

<Columns>
<Column title="✅ Rebase Advantages">
- Creates clean, linear history
- Easy to understand sequence of changes
- No unnecessary merge commits
- Your commits appear recent and relevant
- Easier code review process
</Column>

<Column title="❌ Rebase Disadvantages">
- Rewrites commit history
- Can be intimidating for beginners
- Requires force pushing
- Need to resolve conflicts step by step
- Potential to lose work if done incorrectly
</Column>
</Columns>

## Solution 2: Merge Strategy

The merge strategy preserves the original history and creates explicit merge commits showing when branches were integrated. It creates a new commit that combines the changes from both branches.

<Steps>

### Update your local release branch

```bash
git checkout release
git pull origin release
```

### Switch to your feature branch

```bash
git checkout erik/eng-984-your-feature
```

### Merge updated release into your feature branch

```bash
git merge release
```

### Push normally (no force needed)

```bash
git push origin erik/eng-984-your-feature
```

</Steps>

### Advantages & Disadvantages

<Columns>
<Column title="✅ Merge Advantages">
- Preserves original development history
- No history rewriting
- Safer for inexperienced Git users
- No force push required
- Clear merge points in history
</Column>

<Column title="❌ Merge Disadvantages">
- Creates additional merge commits
- More complex branching history
- Can be harder to follow development flow
- "Noisy" commit graph
- May require resolving the same conflicts twice
</Column>
</Columns>

## Strategy Comparison

Both strategies solve the problem, but with different trade-offs.

| Aspect | Rebase | Merge | No Update |
|--------|---------|--------|-----------|
| **History** | Clean & Linear | Preserved but Complex | Confusing & Messy |
| **PR Review** | Only your changes | Only your changes | Mixed changes |
| **Safety** | Requires force push | Safe, normal push | Merge conflicts later |
| **Learning Curve** | Moderate | Easy | Very Easy (but wrong) |

### When to Use Each Strategy

<AccordionGroup>

<Accordion title="Choose Rebase When:">
- You want clean, linear project history
- Your team values easy-to-follow commit graphs
- You're working on small, focused features
- Team members are comfortable with Git
</Accordion>

<Accordion title="Choose Merge When:">
- You want to preserve the exact development history
- The team includes junior developers
- You're working on long-running feature branches
- Compliance requires complete audit trails
</Accordion>

</AccordionGroup>

## Best Practices & Guidelines

### Universal Best Practices

- **Update Frequently**: Pull from `origin/release` at least daily
- **Communicate**: Know what others are working on
- **Keep Features Small**: Shorter-lived branches lead to fewer conflicts
- **Test After Updating**: Always verify your changes still work
- **Use `--force-with-lease`**: It's safer than `--force` for rebasing

<Tip>
Choose one strategy as a team and stick to it. Mixed approaches create confusion and inconsistent history.
</Tip>

### What Never to Do

<Warning>
Avoid these common mistakes:
- **Never** create PRs without updating your branches first
- **Never** force push to shared branches like `main` or `release`
- **Never** rebase commits that have been pushed and are being used by others
- **Never** mix strategies randomly within the team
</Warning>

## Quick Reference Guide

### Command Cheat Sheet

| Strategy | Commands |
|----------|----------|
| **Rebase** | `git checkout release`<br/>`git pull origin release`<br/>`git checkout your-feature-branch`<br/>`git rebase release`<br/>`git push --force-with-lease` |
| **Merge** | `git checkout release`<br/>`git pull origin release`<br/>`git checkout your-feature-branch`<br/>`git merge release`<br/>`git push origin your-feature-branch` |

### Emergency Procedures

#### If Rebase Goes Wrong

Abort the rebase to return to the original state:

```bash
git rebase --abort
```

#### Fix a PR After It's Created

You can still fix a PR that has already been created. The existing PR will update automatically.

```bash
git checkout release
git pull origin release
git checkout your-feature-branch
git rebase release  # or git merge release
git push --force-with-lease  # if you rebased
```

### Decision Tree

<Info>
**Quick Decision**: Want clean history and are comfortable with Git? → **Rebase**. Want it safe and simple? → **Merge**.

Either way, **ALWAYS** update your branches before creating a PR!
</Info>

### Support Resources

- **Slack**: Ask questions in the `#engineering` channel
- **Pair Programming**: Work through conflicts with a colleague
- **Git Docs**: [https://git-scm.com/docs](https://git-scm.com/docs)